1. <font color="sky-blue">iot.h 헤더 파일은 반드시 필요합니다.</font>
	  - 헤더 파일은 컴파일러에게 함수나 클래스가 어떻게 생겼는지(즉, 시그니처와 구조)를 알려주기 때문에, 코드 내에서 해당 함수나 클래스를 사용할 때 필수적으로 포함되어야 합니다.
2. <font color="sky-blue">iot.h는 인터페이스만 제공하고, 실제 구현은 심볼 매칭에 의해 결정됩니다.</font>
	  - 헤더 파일에 작성된 함수 선언은 “이런 이름의 함수가 어딘가에 있다”라는 정보를 제공합니다.
	  - 컴파일된 오브젝트 파일(.o) 또는 라이브러리 내에 동일한 심볼(함수 이름과 네임스페이스 등)이 있으면, 링커가 이를 연결해 줍니다.
	  - 따라서 실제 구현이 포함된 파일의 이름이 다르더라도, 심볼이 일치하면 그 구현을 사용할 수 있습니다.
3. "인터페이스만 제공한다"는 의미와 컴파일 과정을 이해해야 하는가?
	- 인터페이스 제공이란 헤더 파일이 함수나 클래스의 선언(이름, 매개변수, 리턴타입 등)만 포함하고, 실제 코드(함수 몸체)는 포함하지 않는다는 뜻입니다.
	- 이 개념은 C++에서 헤더와 소스 파일이 어떻게 역할을 분담하는지에 대한 기본적인 이해가 필요합니다.
	- 컴파일 과정을 자세히 알지 않아도 "헤더는 선언, 소스 파일은 구현"이라는 원칙 정도는 알고 있으면 충분합니다.
	- 다만, 링커가 여러 오브젝트 파일에서 동일한 심볼을 찾아 연결하는 과정을 이해하면, 왜 실제 구현 파일의 이름이 달라도 상관없는지를 더 명확하게 알 수 있습니다.

요약하면,
1. 헤더 파일(iot.h) 는 인터페이스(선언부)를 제공하여 다른 파일들이 함수와 클래스를 사용할 수 있게 해주고,
2. 실제 구현은 링커에 의해 심볼 매칭으로 결정되므로 파일 이름과 상관없이 올바른 구현이 사용됩니다.
3. "인터페이스만 제공"한다는 개념은 기본적인 C++ 빌드 과정을 이해하면 자연스럽게 받아들일 수 있는 개념입니다.


### 1. 전처리(Preprocessing)
- 헤더 파일 포함:
소스 파일(.cpp)은 #include "iot.h" 같은 지시문을 통해 헤더 파일을 포함합니다.
헤더 파일에는 함수나 클래스의 **선언(declaration)**만 들어있어, "이 함수는 이런 형태다" 정도의 정보만 제공합니다.
- 매크로 확장:
전처리기는 매크로, 조건부 컴파일, 파일 포함 등을 처리하여 소스 코드를 확장합니다.
### 2. 컴파일(Compilation)
- 소스 파일 → 오브젝트 파일:
각 소스 파일(.cpp)은 개별적으로 컴파일되어 오브젝트 파일(.o 또는 .obj)로 변환됩니다.
이 과정에서 컴파일러는 헤더 파일에 있는 선언을 참고하여 소스 코드에 쓰인 함수와 클래스의 사용법이 올바른지 확인합니다.
- 심볼 테이블 생성:
컴파일러는 각 오브젝트 파일 내에 “심볼(symbol)”이라는 목록을 만듭니다.
여기에는 함수 이름, 변수 이름 등이 들어가며, 어떤 함수는 **정의(implementation)**가 포함되어 있고, 어떤 함수는 선언만 되어 있을 수 있습니다.
- 정의와 미정의 심볼:
만약 오브젝트 파일 내에서 함수의 구현(정의)이 없다면, 그 함수는 미해결(unresolved) 심볼로 남게 됩니다.
예를 들어, iot::chain::checkHealth는 헤더에서는 선언만 되어 있고, 실제 구현은 다른 파일(iot.cc 또는 iot_mock_dynamic.cc)에 있습니다.
	- <font color="sky-blue">헤더파일은 컴파일 시 복사 붙여넣기 되며, 이때 구현은 없는 상태로 컴파일 될 수 있다. (미해결 심볼) 인터페이스를 올바로 사용했는지만 검사한다.</font>
### 3. 링킹(Linking)
- 여러 오브젝트 파일의 결합:
링커는 컴파일된 여러 오브젝트 파일과 라이브러리를 모아 하나의 실행 파일이나 라이브러리를 만듭니다.
- 심볼 해석(Symbol Resolution):
링커는 각 오브젝트 파일의 심볼 테이블을 참고하여, 미해결 심볼에 대해 실제 정의가 어디 있는지 찾아 연결합니다.
예를 들어, Cat.cc에서 호출하는 iot::chain::checkHealth에 대한 미해결 심볼을 찾아, 모의(mock) 라이브러리(iot_mock_dynamic.cc)에 있는 구현을 사용하게 됩니다.
- 우선순위와 대체:
동일한 심볼이 여러 개의 오브젝트 파일이나 라이브러리에 있다면, 링커는 빌드 설정이나 라이브러리 링크 순서에 따라 어느 것이 최종적으로 사용될지를 결정합니다.
테스트 빌드에서는 production 코드(iot.cc) 대신 테스트용 mock 구현(iot_mock_dynamic.cc)이 링크되도록 설정함으로써, iot::chain::checkHealth 호출이 모의 함수로 대체됩니다.
### 4. 결과: 인터페이스와 구현의 분리
- 헤더 파일(iot.h):
헤더는 인터페이스(선언부)를 제공하며, 어떤 함수가 어떻게 호출될 수 있는지 정보를 줍니다.
실제 구현은 헤더 파일이 아니라 별도의 소스 파일(.cc)에 있습니다.
- 함수 심볼 매칭:
링커는 “iot::chain::checkHealth”라는 심볼을 찾아, 여러 오브젝트 파일 중에서 가장 적절한 정의를 연결합니다.
그래서 동일한 심볼 이름을 가진 함수가 production 코드(iot.cc)와 테스트용 모의 코드(iot_mock_dynamic.cc) 중 하나로 연결되는 것입니다.
- 빌드 설정에 따른 선택:
CMake 같은 빌드 시스템에서, 테스트 빌드시에는 모의(mock) 구현을 포함하도록 설정함으로써, Cat.cc가 모의 함수로 동작하게 할 수 있습니다.
### 결론
- 헤더 파일의 역할:
헤더 파일은 인터페이스만 제공하여 컴파일러가 함수와 클래스의 사용법을 알 수 있도록 합니다.
- 오브젝트 파일과 심볼:
각 소스 파일은 컴파일되어 오브젝트 파일이 되고, 여기에 함수와 변수의 이름(심볼)이 기록됩니다.
- 링커의 역할:
링커는 여러 오브젝트 파일의 심볼을 모아, 미해결 심볼에 대해 올바른 정의를 찾아 실행 파일을 완성합니다.
이 과정에서 빌드 설정에 따라 production 구현 대신 테스트용 mock 구현을 연결할 수 있습니다.

이러한 과정을 이해하면, 왜 Cat.cc가 iot.h를 포함하고 있음에도 불구하고, 테스트에서는 별도의 모의(mock) 구현(iot_mock_dynamic.h/cc)을 통해 함수 호출이 대체될 수 있는지를 명확히 알 수 있습니다.